System.register(["./index-legacy-BPR4r8r3.js"],(function(t,a){"use strict";var e,c,r,l,s,n,o,i,u,d,h,f,m;return{setters:[t=>{e=t.x,c=t.y,r=t.A,l=t.C,s=t.D,n=t.E,o=t.R,i=t.G,u=t.H,d=t.I,h=t.J,f=t.K,m=t.l}],execute:function(){async function a(t,a){const{allowFailure:h=!0,batchSize:f,blockNumber:m,blockTag:b,multicallAddress:g,stateOverride:w}=a,N=a.contracts,p=f??("object"==typeof t.batch?.multicall&&t.batch.multicall.batchSize||1024);let k=g;if(!k){if(!t.chain)throw new Error("client chain not configured. multicallAddress is required.");k=e({blockNumber:m,chain:t.chain,contract:"multicall3"})}const y=[[]];let v=0,x=0;for(let e=0;e<N.length;e++){const{abi:t,address:a,args:l,functionName:s}=N[e];try{const e=c({abi:t,args:l,functionName:s});x+=(e.length-2)/2,p>0&&x>p&&y[v].length>0&&(v++,x=(e.length-2)/2,y[v]=[]),y[v]=[...y[v],{allowFailure:!0,callData:e,target:a}]}catch(c){const n=r(c,{abi:t,address:a,args:l,docsPath:"/docs/contract/multicall",functionName:s});if(!h)throw n;y[v]=[...y[v],{allowFailure:!0,callData:"0x",target:a}]}}const F=await Promise.allSettled(y.map((a=>l(t,d,"readContract")({abi:s,address:k,args:[a],blockNumber:m,blockTag:b,functionName:"aggregate3",stateOverride:w})))),I=[];for(let e=0;e<F.length;e++){const t=F[e];if("rejected"===t.status){if(!h)throw t.reason;for(let a=0;a<y[e].length;a++)I.push({status:"failure",error:t.reason,result:void 0});continue}const c=t.value;for(let l=0;l<c.length;l++){const{returnData:t,success:s}=c[l],{callData:u}=y[e][l],{abi:d,address:f,functionName:m,args:b}=N[I.length];try{if("0x"===u)throw new n;if(!s)throw new o({data:t});const a=i({abi:d,args:b,data:t,functionName:m});I.push(h?{result:a,status:"success"}:a)}catch(a){const t=r(a,{abi:d,address:f,args:b,docsPath:"/docs/contract/multicall",functionName:m});if(!h)throw t;I.push({error:t,result:void 0,status:"failure"})}}}if(I.length!==N.length)throw new u("multicall results mismatch");return I}async function b(t,e){const{allowFailure:c=!0,chainId:r,contracts:l,...s}=e,n=t.getClient({chainId:r});return h(n,a,"multicall")({allowFailure:c,contracts:l,...s})}t("r",(async function(t,a){const{allowFailure:e=!0,blockNumber:c,blockTag:r,...l}=a,s=a.contracts;try{const a={};for(const[e,c]of s.entries()){const r=c.chainId??t.state.chainId;a[r]||(a[r]=[]),a[r]?.push({contract:c,index:e})}const n=()=>Object.entries(a).map((([a,s])=>b(t,{...l,allowFailure:e,blockNumber:c,blockTag:r,chainId:Number.parseInt(a),contracts:s.map((({contract:t})=>t))}))),o=(await Promise.all(n())).flat(),i=Object.values(a).flatMap((t=>t.map((({index:t})=>t))));return o.reduce(((t,a,e)=>(t&&(t[i[e]]=a),t)),[])}catch(l){if(l instanceof f)throw l;const a=()=>s.map((a=>m(t,{...a,blockNumber:c,blockTag:r})));return e?(await Promise.allSettled(a())).map((t=>"fulfilled"===t.status?{result:t.value,status:"success"}:{error:t.reason,result:void 0,status:"failure"})):await Promise.all(a())}}))}}}));
