import{x as a,y as t,A as e,C as l,D as s,E as r,R as c,G as n,H as o,I as i,J as u,K as d,l as h}from"./index-B6-Orl3I.js";async function f(u,d){var h;const{allowFailure:f=!0,batchSize:m,blockNumber:b,blockTag:g,multicallAddress:w,stateOverride:p}=d,N=d.contracts,k=null!=m?m:"object"==typeof(null==(h=u.batch)?void 0:h.multicall)&&u.batch.multicall.batchSize||1024;let v=w;if(!v){if(!u.chain)throw new Error("client chain not configured. multicallAddress is required.");v=a({blockNumber:b,chain:u.chain,contract:"multicall3"})}const y=[[]];let x=0,F=0;for(let a=0;a<N.length;a++){const{abi:l,address:s,args:r,functionName:c}=N[a];try{const a=t({abi:l,args:r,functionName:c});F+=(a.length-2)/2,k>0&&F>k&&y[x].length>0&&(x++,F=(a.length-2)/2,y[x]=[]),y[x]=[...y[x],{allowFailure:!0,callData:a,target:s}]}catch(j){const a=e(j,{abi:l,address:s,args:r,docsPath:"/docs/contract/multicall",functionName:c});if(!f)throw a;y[x]=[...y[x],{allowFailure:!0,callData:"0x",target:s}]}}const I=await Promise.allSettled(y.map((a=>l(u,i,"readContract")({abi:s,address:v,args:[a],blockNumber:b,blockTag:g,functionName:"aggregate3",stateOverride:p})))),P=[];for(let a=0;a<I.length;a++){const t=I[a];if("rejected"===t.status){if(!f)throw t.reason;for(let e=0;e<y[a].length;e++)P.push({status:"failure",error:t.reason,result:void 0});continue}const l=t.value;for(let s=0;s<l.length;s++){const{returnData:t,success:o}=l[s],{callData:i}=y[a][s],{abi:u,address:d,functionName:h,args:m}=N[P.length];try{if("0x"===i)throw new r;if(!o)throw new c({data:t});const a=n({abi:u,args:m,data:t,functionName:h});P.push(f?{result:a,status:"success"}:a)}catch(j){const a=e(j,{abi:u,address:d,args:m,docsPath:"/docs/contract/multicall",functionName:h});if(!f)throw a;P.push({error:a,result:void 0,status:"failure"})}}}if(P.length!==N.length)throw new o("multicall results mismatch");return P}async function m(a,t){var e,l;const{allowFailure:s=!0,blockNumber:r,blockTag:c,...n}=t,o=t.contracts;try{const t={};for(const[s,r]of o.entries()){const c=null!=(e=r.chainId)?e:a.state.chainId;t[c]||(t[c]=[]),null==(l=t[c])||l.push({contract:r,index:s})}const i=()=>Object.entries(t).map((([t,e])=>async function(a,t){const{allowFailure:e=!0,chainId:l,contracts:s,...r}=t,c=a.getClient({chainId:l});return u(c,f,"multicall")({allowFailure:e,contracts:s,...r})}(a,{...n,allowFailure:s,blockNumber:r,blockTag:c,chainId:Number.parseInt(t),contracts:e.map((({contract:a})=>a))}))),d=(await Promise.all(i())).flat(),h=Object.values(t).flatMap((a=>a.map((({index:a})=>a))));return d.reduce(((a,t,e)=>(a&&(a[h[e]]=t),a)),[])}catch(i){if(i instanceof d)throw i;const t=()=>o.map((t=>h(a,{...t,blockNumber:r,blockTag:c})));return s?(await Promise.allSettled(t())).map((a=>"fulfilled"===a.status?{result:a.value,status:"success"}:{error:a.reason,result:void 0,status:"failure"})):await Promise.all(t())}}export{m as r};
